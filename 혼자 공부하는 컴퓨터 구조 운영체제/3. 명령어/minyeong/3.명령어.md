# Chapter 03. 명령어
- [Chapter 03. 명령어](#chapter-03-명령어)
- [03-1. 소스 코드와 명령어](#03-1-소스-코드와-명령어)
  - [고급 언어와 저급 언어](#고급-언어와-저급-언어)
  - [컴파일 언어와 인터프리터 언어](#컴파일-언어와-인터프리터-언어)
- [03-2. 명령어의 구조](#03-2-명령어의-구조)
  - [**명령어**](#명령어)
    - [**연산 코드**](#연산-코드)
    - [**오퍼랜드**](#오퍼랜드)
  - [주소 지정 방식](#주소-지정-방식)
    - [즉시 주소 지정 방식](#즉시-주소-지정-방식)
    - [직접 주소 지정 방식](#직접-주소-지정-방식)
    - [간접 주소 지정 방식](#간접-주소-지정-방식)
    - [레지스터 주소 지정 방식](#레지스터-주소-지정-방식)
    - [레지스터 간접 주소 지정 방식](#레지스터-간접-주소-지정-방식)
- [Q\&A](#qa)


# 03-1. 소스 코드와 명령어

## 고급 언어와 저급 언어

- **고급 언어** : 사람을 위한 언어 (프로그래밍 언어)
- **저급 언어** : 컴퓨터가 직접 이해하고 실행할 수 있는 언어
    - **기계어** : 0과 1의 명령어 비트로 이루어진 언어
    - **어셈블리어** : 기계어를 읽기 편한 형태로 번역한 언어
    
    ![Untitled](./Chapter%2003%20명령어%20img/Untitled%201.png)
    

## 컴파일 언어와 인터프리터 언어

![Untitled](./Chapter%2003%20명령어%20img/Untitled.png)

- **컴파일 언어**
    - **컴파일러**에 의해 **소스 코드 전체**가 **저급 언어로 변환**되어 실행되는 **고급 언어**
        - **컴파일** : 컴파일 언어로 작성된 소스 코드 전체가 저급 언어로 변환되는 과정
        - **컴파일러** : 컴파일 수행 도구
    - 컴파일러가 소스 코드 내에서 오류를 하나라도 발견했을 시 컴파일 실패
    - 성공하면 저급 언어로 변환 ⇒ **목적 코드**
    - 대표 언어 : C
    
- **인터프리터 언어**
    - **인터프리터**에 의해 **소스 코드가 한 줄씩** 실행되는 고급 언어
        - **인터프리터** : 소스 코드를 한 줄씩 저급 언어로 변환하여 실행해주는 도구
    - N번째 줄에 오류가 발생하면 N-1번째 줄까지 올바르게 수행
    - **소스 코드 마지막에 이를 때까지 한 줄씩 저급 언어로 해석하며 실행해야 하기 때문에 컴파일 언어보다 느림**
    - 대표 언어 : Python

- **참고 : 컴파일과 인터프리트 관계**
    
    컴파일 언어와 인터프리터 언어 간의 경계가 모호한 경우 많음
    
    Python도 컴파일 하는 경우가 있으며, Java는 컴파일과 인터프리트 동시 수행
    
    따라서 고급 언어가 저급 언어로 변환되는 대표적인 방법으로 컴파일 방식과 인터프리트 방식이 있다 정도만 이해하는 것이 좋음
    
- **참고 : 목적 파일 vs 실행 파일**
    
    **목적 파일** : 목적 코드로 이루어진 파일
    
    **실행 파일** : 실행 코드로 이루어진 파일 (ex 윈도우 .exe 확장자 가진 파일)
    
    목적 코드가 실행 파일이 되려면 **링킹** 거쳐야 함 ⇒ 저급 언어 외의 기능들 즉 외부 기능을 연결 짓는 작업
    

    

# 03-2. 명령어의 구조

## **명령어**

- **명령어 = 연산 코드 + 오퍼랜드**
- **연산 코드** : 명령어가 수행할 연산 (연산자)
    - 연산 코드 필드 : 연산 코드가 담기는 영역
- **오퍼랜드** : 연산에 사용할 데이터 또는 그 데이터가 저장된 위치 ( 피연산자)
    - 오퍼랜드 필드 : 오퍼랜드가 담기는 영역

### **연산 코드**

<aside>
📤 **데이터 전송**

- MOVE : 데이터를 옮겨라
- STORE : 메모리에 저장하라
- LOAD (FETCH) : 메모리에서 CPU로 데이터를 가져와라
- PUSH : 스택에 데이터를 저장하라
- POP : 스택의 최상단 데이터를 가져와라
</aside>

<aside>
🔢 **산술 / 논리 연산**

- ADD / SUBTRACT / MULTIPLY / DIVIDE : 덧셈 / 뺄셈 / 곱셈 / 나눗셈을 수행하라
- INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 1을 빼라
- AND / OR / NOT : AND / OR / NOT 연산을 수행하라
- COMPARE : 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라
</aside>

<aside>
🔃 **제어 흐름 변경**

- JUMP : 특정 주소로 실행 순서를 옮겨라
- CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
- HALT : 프로그램의 실행을 멈춰라
- CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
- RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라
</aside>

<aside>
⛔ **입출력 제어**

- READ (INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
- WRITE (OUTPUT) : 특정 입출력 장치로 데이터를 써라
- START IO : 입출력 장치를 시작하라
- TEST IO : 입출력 장치의 상태를 확인하라
</aside>

### **오퍼랜드**

- 오퍼랜드 필드 = 주소 필드
    - 메모리 주소나 레지스터 이름 담김 (연산에 사용할 데이터가 저장된 위치)
    - 명령어 안에 하나도 없을 수 있고, 여러 개 있을 수 있음
        - 0-주소 명령어 : 오퍼랜드 하나도 없는 명령어
        - 1-주소 명령어 : 오퍼랜드 하나인 명령어 등
        

## 주소 지정 방식

- 오퍼랜드 필드 안에 명령어 길이가 길어질 경우 담을 수 있는 정보의 가짓수가 적어지기 때문에 메모리 주소를 담아 표현할 수 있는 데이터의 크기를 확보
- 주소 지정 방식
    - 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 **연산에 사용할 데이터 위치를 찾는 방법**
    - **유효 주소 찾는 방법**
        - 유효 주소 : 연산의 대상이 되는 데이터가 저장된 위치

### 즉시 주소 지정 방식

- 연산에 사용할 **데이터를 직접 명시**
- 장점 : 빠름 → 데이터를 찾는 과정 없기 때문
- 단점 : 표현할 수 있는 데이터의 크기 작아짐

### 직접 주소 지정 방식

- **유효 주소를 직접적으로 명시**
- 장점 : 표현할 수 있는 데이터의 크기가 커짐
- 단점 : 표현할 수 있는 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한 생길 수 있음

### 간접 주소 지정 방식

- **유효 주소의 주소를 명시**
- 장점 : 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위 더 넓어짐
- 단점 : 두 번의 메모리 접근이 필요해 상대적으로 느림

### 레지스터 주소 지정 방식

- 연산에 사용할 데이터를 저장한 **레지스터를 오퍼랜드 필드에 직접 명시**
- 장점 : 직접 주소 지정 방식보다 빠르게 데이터에 접근 가능
- 단점 : 표현할 수 있는 레지스터 크기에 제한 생길 수 있음

### 레지스터 간접 주소 지정 방식

- 연산에 사용할 데이터를 **메모리에 저장**하고, 그 주소를 **저장한 레지스터를 오퍼랜드 필드에 명시**
- 메모리에 접근하는 횟수 한 번

- **요약 정리**
    
    ![Untitled](./Chapter%2003%20명령어%20img/Untitled%202.png)
    
- **참고 : 스택과 큐**
    
    **스택** : 한 쪽 끝이 막혀 있는 저장 공간
    
    - LIFO (후입 선출)
    - PUSH : 새로운 데이터 저장하는 명령어
    - POP : 저장된 데이터를 꺼내는 명령어
    
    **큐** : 양 쪽이 뚫려 있는 저장 공간
    
    - FIFO (선입 선출)

# Q&A

1. **컴파일 언어와 인터프리터 언어의 차이점을 설명하시오.**
2. **명령어의 구조에 대해 간략히 설명하시오.**
3. **주소 지정 방식이 무엇인지 설명하고, 직접 주소 방식과 간접 주소 방식의 차이점에 대해 설명하시오.**

- 1번 답
    
    **컴파일 언어**는 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어이다. 반면, **인터프리터 언어**는 인터프리터에 의해 소스 코드 한 줄씩 저급 언어로 변환되어 실행되는 고급 언어이다.
    
- 2번 답
    
    명령어는 연산 코드와 오퍼랜드로 구성되어 있다. 연산 코드는 명령어가 수행할 연산이며, 오퍼랜드는 연산에 사용할 데이터 또는 그 데이터가 저장된 위치이다.
    
- 3번 답
    
    주소 지정 방식이란 유효 주소를 찾는 방법이다. 유효 주소는 연산의 대상이 되는 데이터가 저장된 위치인데, 오퍼랜드 필드 안에 명령어의 길이가 길어지면 담을 수 있는 정보의 가짓 수가 적어지기 때문에 메모리 주소를 담아 표현할 수 있는 데이터 크기를 확보한다.
    
    직접 주소 방식은 유효 주소를 직접적으로 명시하는 반면, 간접 주소 방식은 유효 주소의 주소를 명시한다. 따라서 간접 주소 방식은 직접 주소 방식에 비해 상대적으로 표현할 수 있는 유효 주소의 범위가 더 넓지만, 두 번의 메모리 접근이 필요해 느리다는 특징이 있다.