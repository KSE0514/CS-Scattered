# 혼자 공부하는 컴퓨터 구조 운영체제 

- [혼자 공부하는 컴퓨터 구조 운영체제](#혼자-공부하는-컴퓨터-구조-운영체제)
- [3. 명령어](#3-명령어)
  - [소스 코드와 명령어](#소스-코드와-명령어)
    - [고급 언어와 저급 언어](#고급-언어와-저급-언어)
      - [저급 언어의 종류](#저급-언어의-종류)
    - [컴파일 언어와 인터프리터 언어](#컴파일-언어와-인터프리터-언어)
    - [컴파일 언어](#컴파일-언어)
    - [인터프리터 언어](#인터프리터-언어)
    - [목적 파일 VS 실행 파일](#목적-파일-vs-실행-파일)
  - [명령어의 구조](#명령어의-구조)
    - [연산 코드와 오퍼랜드](#연산-코드와-오퍼랜드)
    - [오퍼랜드](#오퍼랜드)
    - [연산 코드](#연산-코드)
    - [주소 지정 방식](#주소-지정-방식)
  - [스택과 큐](#스택과-큐)
    - [스택](#스택)
    - [큐](#큐)
  - [Q\&A](#qa)
    - [Q1. 저급 언어와 고급 언어를 설명하고 이와 연결지어 소스코드를 변환하는 방식을 설명해주세요.](#q1-저급-언어와-고급-언어를-설명하고-이와-연결지어-소스코드를-변환하는-방식을-설명해주세요)
    - [Q2. 명령어의 구조는 어떻게 이루어져있나요?](#q2-명령어의-구조는-어떻게-이루어져있나요)
    - [Q3. 5가지 주소 지정 방식에 대해 간단히 설명하시오.](#q3-5가지-주소-지정-방식에-대해-간단히-설명하시오)


# 3. 명령어
## 소스 코드와 명령어
- 컴퓨터는 명령어를 처리하는 기계
- 모든 프로그래밍 언어로 만든 소스 코드는 컴퓨터 내부에서 명령어로 변환됨

### 고급 언어와 저급 언어
1. 고급 언어 : 사람을 위한 언어로 사람이 이해하고 작성하기 쉽게 만들어짐, 컴퓨터가 이해할 수 없음
2. 저급 언어 : 컴퓨터가 직접 이해하고 실행할 수 있는 언어, 명령어로 이루어져 있음  
   
> => 고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어(명령어)로 이루어져 있음

#### 저급 언어의 종류
1. 기계어 : 0과 1의 명령어 비트로 이루어진 언어, 가독성을 위해 십육진수로 표현하기도 함
2. 어셈블리어 : 0과 1로 표현된 명령어(기계어)를 읽기 편한 형태로 번역한 언어, 한 줄씩 명령어가 됨
   - 컴퓨터가 프로그램을 실행하는 과정과 어떤 절차로 작동하는지를 추적할 수 있음

> - 개발자가 어셈블리어로 복잡한 프로그램을 만들기는 어려움, 고급 언어는 사람이 읽고 쓰기 편하고 가독성이 더 좋고, 변수나 함수 같은 편리한 문법을 제공하여 복잡한 프로그램을 구현할 수 있음
> 
> - 그러나 어셈블리어도 하드웨어와 밀접하게 맞닿아 있는 프로그램을 개발하는 임베디드 개발자, 게임 개발자, 정보 보안 분야 등에서 사용됨

::: mermaid
flowchart TD;
    고급_언어-->소스_코드_변환_방식;
    소스_코드_변환_방식-->컴파일;
    소스_코드_변환_방식-->인터프리트;
    저급_언어-->기계어;
    저급_언어-->어셈블리어;
:::

### 컴파일 언어와 인터프리터 언어
- 고급 언어로 작성한 소스 코드를 저급 언어로 변환하는 방식

### 컴파일 언어
- 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어
- 컴파일을 수행해 주는 도구 = 컴파일러
- 소스 코드 내 오류를 하나라도 발견하면 해당 소스 코드 컴파일에 실패
- 컴파일러를 통해 저급 언어로 변환된 코드를 '목적 코드'라고 함
- 예 : C언어

### 인터프리터 언어
- 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어
- 소스 코드를 한 줄씩 차례로 실행됨
- 한 줄씩 저급 언어로 변환하여 실행해 주는 도구 = 인터프리터
  - 한 줄씩 실행하기 때문에 소스 코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없음
  - 오류가 있기 직전 줄까지는 올바르게 수행됨
- 컴파일 언어보다 일반적으로 느림
- 예 : Python

### 목적 파일 VS 실행 파일
- 목적 코드로 이루어진 파일 = 목적 파일
- 실행 코드로 이루어진 파일 = 실행 파일
  - 예 : 윈도우 .exe 파일

> - 목적 코드가 실행 파일이 되기 위해서는 '링킹'이라는 작업을 거쳐야 함  
>
> - 특정 목적 코드에 없는 외부 기능들을 목적 코드와 연결 짓는 작업이 필요 => 이게 링킹

---
[목차로 돌아가기](#)

---

## 명령어의 구조
- 연산 코드, 오퍼랜드, 주소 지정 방식
### 연산 코드와 오퍼랜드
- 명령어의 구조 : 무엇을 대상으로, 어떤 작동을 수행하라
- 명령의 작동(연산), 연산에 사용할 데이터, 연산에 사용할 데이터가 저장된 위치

<br>

- 명령어 : 연산 코드와 오퍼랜드로 구성됨
  1. 연산 코드 (연산자) : 명령어가 수행할 연산
    - 연산 코드 필드 : 연산 코드가 담기는 영역
  2. 오퍼랜드 (피연산자) : 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치
    - 오퍼랜드 필드 :  오퍼랜드가 담기는 영역

<br>

### 오퍼랜드
- 연산에 사용할 데이터, 연산에 사용할 데이터가 저장된 위치
- 숫자, 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있음
- 대부분 연산에 사용할 데이터가 저장된 위치(메모리 주소, 레지스터 이름)가 담김
  - 오퍼랜드 필드를 주소 필드라고 부르기도 하는 이유
- 오퍼랜드는 명령어 안에 아예 없거나 한개만 있거나 여러개 있을 수 있음
  - 아예 없는 경우 : 0-주소 명령어
  - 1개인 경우  : 1-주소 명령어
  - 2개인 경우 : 2-주소 명령어
  - 3개인 경우 : 3-주소 명령어

### 연산 코드
- 명령어가 수행할 연산
- 연산 코드의 네 가지 유형
  1. 데이터 전송
   > MOVE(데이터 옮기기),  
    STORE(메모리에 저장하기),  
    LOAD(FETCH, 메모리에서 CPU로 데이터 가져오기),  
    PUSH(스택에 데이터를 저장하기),  
    POP(스택의 최상단 데이터를 가져오기)
  2. 산술/논리 연산
   > ADD/SUBTRACT/MULTIPLY/DIVIDE : 덧셈 / 뺄셈 / 곱셈 / 나눗셈  
   INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라  
   AND / OR / NOT : AND / OR /NOT 연산을 수행하라  
   COMPARE : 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라
  3. 제어 흐름 변경
   > JUMP : 특정 주소로 실행 순서를 옮겨라  
   CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라  
   HALT : 프로그램의 실행을 멈춰라  
   CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
   RETURN CALL : CALL을 호출할 때 저장했던 주소로 돌아가라
  4. 입출력 제어
   > READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
   WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라  
   START IO : 입출력 장치를 시작하라  
   TEST IO : 입출력 장치의 상태를 확인하라  

### 주소 지정 방식
- n비트(명령어) = m비트(연산 코드 필드) - (n-m)(오퍼랜드 필드)
  - 하나의 명령어가 n 비트로 구성될 때 연산 코드 필드가 m비트이면 오퍼랜드 필드에 할당할 수 있는 공간은 n-m
  - 오퍼랜드 필드가 표현할 수 있는 명령어 개수 = 2^(n-m)
- 미리 메모리에 데이터를 저장하고 오퍼랜드 필드 안에 ***메모리 주소***를 명시하면 메모리가 저장할 수 있는 공간만큼 표현할 수 있는 가짓수가 커짐

<br>

- 유효 주소 : 연산 코드에 사용할 데이터가 저장된 위치

- 주소 지정 방식 : 연산에 사용할 데이터 위치를 찾는 방법, 유효 주소를 찾는 방법  
  1. 즉시 주소 지정 방식 (연산에 사용할 데이터)  
   - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
   - 표현할 수 있는 데이터의 크기가 작아짐
   - 주소를 찾는 과정이 없기 때문에 빠름
  2. 직접 주소 지정 방식 (유효 주소, 메모리 주소)
   - 오퍼랜드 필드에 유효 주소를 직접 명시하는 방식
   - 표현할 수 있는 데이터의 크기는 즉시 주소 지정 방식보다 커졌지만 여전히 연산 코드의 길이만큼 짧아져 유효 주소에 제한이 생길 수 있음
  3. 간접 주소 지정 방식 (유효 주소의 주소)
  - 유효 주소의 주소를 오퍼랜드 필드에 명시
  - 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 넓어짐
  - 두 번의 메모리 접근이 필요하여 다른 것들보다 느린 방식
  4. 레지스터 주소 지정 방식 (레지스터 이름)
   - 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
   - CPU 외부에 있는 메모리보다 CPU 내부에 있는 레지스터 접근하는 게 더 빠름
   - 레지스터 접근 방식은 직접 주소 지정 방식보다 빠르게 데이터에 접근 가능
   - 표현할 수 있는 레지스터 크기에 제한
  5. 레지스터 간접 주소 지정 방식 (유효 주소를 저장한 레지스터)
   - 연산에 사용할 데이터를 메모리에 저장하고 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시
   - 간접 주소 지정 방식과 비슷하지만 메모리에 접근하는 횟수가 한번으로 줄어듦
   - 간접 주소 지정 방식보다 레지스터 간접 주소 지정 방식이 더 빠름

## 스택과 큐
### 스택
- 스택이란?  
  - 한쪽 끝이 막혀 있는 통과 같은 저장 공간
  - 나중에 저장한 데이터를 가장 먼저 빼내는 데이터 관리 방식 (후입선출)
  - LIFO : Last In First Out
  - PUSH : 새로운 데이터를 저장하는 명령어
  - POP : 스택에 저장된 데이터를 꺼내는 명령어

### 큐
- 큐란?
  - 양쪽이 뚫려있는 통과 같은 저장 공간
  - 한쪽으로는 데이터를 저장하고 다른 한쪽으로는 먼저 저장한 순서대로 데이터를 빼냄
  - 가장 먼저 저장된 데이터부터 빼내는 데이터 관리 방식 (선입선출)
  - FIFO : First In First Out

---
[목차로 돌아가기](#)

---
## Q&A
### Q1. 저급 언어와 고급 언어를 설명하고 이와 연결지어 소스코드를 변환하는 방식을 설명해주세요.
A1. 저급 언어는 컴퓨터가 이해할 수 있는 명령어로 이루어진 기계어와 어셈블리가 있습니다. 이에 반해 고급 언어란 사람이 이해할 수 있는 방식인 프로그래밍 언어로 만들어진 소스 코드입니다. 소스 코드를 변환하는 방식은 전체를 컴파일하여 목적 코드로 넘겨주는 컴파일 방식과 한줄씩 변환하는 인터프리터 방식이 있습니다.

### Q2. 명령어의 구조는 어떻게 이루어져있나요?
A2. 명령어의 구조에는 연산코드인 연산자와 오퍼랜드인 피연산자로 이루어져있습니다. 연산코드는 특정 동작을 작동시키는 명령어이며 오퍼랜드는 연산에 사용할 데이터의 주소나 데이터를 의미합니다.

### Q3. 5가지 주소 지정 방식에 대해 간단히 설명하시오.
A3. 즉시 주소 지정 방식은 연산에 사용할 데이터를 직접 명시하는 방식입니다. 직접 주소 지정 방식는 유효 주소를 직접 명시하는 방식입니다. 간접 주소 지정 방식은 유효 주소의 주소를 명시하는 방법입니다. 레지스터 주소 지정 방식은 레지스터 이름을 직접 명시하는 것입니다. 레지스터 간접 주소 지정 방식은 유효 주소를 저장한 레지스터를 명시하는 방식입니다.

---
[목차로 돌아가기](#)

---