# 혼자 공부하는 컴퓨터 구조 운영체제 
- [혼자 공부하는 컴퓨터 구조 운영체제](#혼자-공부하는-컴퓨터-구조-운영체제)
  - [5. CPU 성능 향상 기법](#5-cpu-성능-향상-기법)
    - [5-1. 빠른 CPU를 위한 설계 기법](#5-1-빠른-cpu를-위한-설계-기법)
      - [클럭](#클럭)
      - [코어와 멀티코어](#코어와-멀티코어)
        - [코어 늘리기](#코어-늘리기)
      - [스레드와 멀티스레드](#스레드와-멀티스레드)
      - [코어와 스레드의 차이](#코어와-스레드의-차이)
    - [5-2. 명령어 병렬 처리 기법](#5-2-명령어-병렬-처리-기법)
      - [명령어 파이프라인](#명령어-파이프라인)
        - [데이터 위험](#데이터-위험)
        - [제어 위험](#제어-위험)
        - [구조적 위험(자원 위험)](#구조적-위험자원-위험)
    - [슈퍼스칼라](#슈퍼스칼라)
    - [비순차적 명령어 처리 (OoOE: Out-of-Order Exection)](#비순차적-명령어-처리-oooe-out-of-order-exection)
  - [5-3. CISC와 RISC](#5-3-cisc와-risc)
    - [명령어 집합](#명령어-집합)
    - [CISC](#cisc)
    - [RISC](#risc)
    - [정리](#정리)
  - [Q\&A](#qa)
    - [Q1. 멀티코어 프로세서와 멀티스레드 프로세서를 설명하시오.](#q1-멀티코어-프로세서와-멀티스레드-프로세서를-설명하시오)
    - [Q2. 명령어 파이프라인과 파이프라인 위험에 대해 설명하고 파이프라인의 위험을 피하기 위한 방식이 무엇인지 설명하시오.](#q2-명령어-파이프라인과-파이프라인-위험에-대해-설명하고-파이프라인의-위험을-피하기-위한-방식이-무엇인지-설명하시오)
    - [Q3. ISA와 CISC, RISC에 대해 설명하시오.](#q3-isa와-cisc-risc에-대해-설명하시오)

## 5. CPU 성능 향상 기법
### 5-1. 빠른 CPU를 위한 설계 기법
#### 클럭
- 컴퓨터 부품들은 '클럭 신호'에 맞춰 움직임
- CPU는 '명령어 사이클'이라는 정해진 흐름에 맞춰 명령어들을 실행  
  => 클럭 신호가 빠르게 반복되면 CPU를 비롯한 컴퓨터 부품들은 빠른 박자에 맞춰 움직임  
  => 클럭 속도는 CPU 속도 단위로 간주되기도 함

- 클럭 속도는 헤르츠(Hz) 단위로 측정
  - 1초에 클럭이 몇번 반복되는지를 나타냄
  - 1GHz = 1,000,000,000(10^9, 1억)Hz

- 클럭 속도는 일정하지 않음
  - CPU는 일정한 클럭 속도를 유지하기보다 고성능을 요하는 순간에는 순간적으로 클럭 속도를 높이고, 그렇지 않을 때는 유연하게 클럭 속도를 낮춤
  - 최대 클럭 속도를 강제적으로 더 끌어올릴 수도 있음 = 오버클럭킹

- 클럭 속도를 무작정 높이면 발열 문제가 심각해짐, 클럭 속도로만으로 CPU의 성능을 올리는 것은 한계가 있음


#### 코어와 멀티코어
- CPU 성능을 높이는 방법 : 클럭 속도를 높이기, CPU의 코어와 스레드 수를 늘리기  

##### 코어 늘리기
- CPU : 명령어를 실행하는 부품 => 원칙적으로 하나만 존재  
  => 기술의 발전으로 ***CPU 내부에 명령어를 실행하는 부품들을 여러개 만들 수 있게 됨***  
  => ***현대적 CPU의 정의 : 명령어를 실행하는 부품을 여러개 포함하는 부품***  

- 코어 : 기술의 발전으로 CPU 내부에 내재된 명령어를 실행하는 부품
  - 예시 : 8코어 = 명령어를 실행하는 부품을 8개 포함하는 것

- 멀티코어 CPU or 멀티코어 프로세서 : 코어를 여러 개 포함하고 있는 CPU
![!\[alt text\](image.png)](<코어별 프로세서 명칭.png>)

- 코어 수에 비례하여 CPU의 연산 속도가 비례하여 증가하지 않음
  - 팀플, 4인분 도시락을 10이 만드는 것과 5명이 만드는 것을 생각해보면 됨  
  => ***코어마다 처리할 명령어들을 얼마나 적절하게 분배하느냐에 따라 연산 속도가 달라짐***

#### 스레드와 멀티스레드
- 스레드(thread)의 사전적 의미 : 실행 흐름의 단위
  
1. 하드웨어적 스레드 : ***하나의 코어가 동시에 처리하는 명령어 단위***   
  - 1코어 1스레드 CPU 
    - 명령어를 실행하는 부품이 한 개 있고 한번에 하나씩 명령어 실행  
  - 여러 스레드를 지원하는 CPU의 경우 하나의 코어로도 여러 개의 명령어를 동시에 실행 가능
    - 2코어 4 스레드 예시
    ![!\[alt text\](image.png)](<2코어 4스레드.png>)
    - 하나의 코어로 여러 명령어를 동시에 처리하는 CPU = ***멀티스레드 프로세서 or 멀티스레드 CPU***
  - 하이퍼스레딩(hyper-threadng) : 인텔의 멀티스레드 기술

<br>

2. 소프트웨어적 스레드 : ***하나의 프로그램에서 독립적으로 샐행되는 단위***
   - 프로그래밍 언어나 운영체제를 학습할 때 접하는 스레드
   - 하나의 프로그램은 실행되는 과정에서 한 부분만 실행될 수도 있지만, 프로그램의 여러 부분이 동시에 실행될 수도 있음
   - 1코어 1스레드 CPU도 소프트웨어적 스레드를 수십 개 실행할 수 있음, 1코어 1스레드 CPU로도 프로그램의 여러 부분을 동시에 실행할 수 있음
    > => 이게 어떻게 가능한걸까?  
    GPT의 답 : 1코어 1스레드 CPU로도 여러 소프트웨어적 스레드를 실행할 수 있는 이유는 CPU가 이 스레드들을 빠르게 전환하면서 실행하기 때문입니다. 이 기술을 통해 여러 작업이 "동시에" 실행되는 것처럼 보이는 것입니다.

- 멀티스레드 프로세서 : 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
  - 가장 큰 핵심은 ***레지스터***
  - 하나의 코어로 여러 명령어를 동시에 처리하도록 만드려면 프로그램 카운터, 스택 포인터, 데이터 버퍼 레지스터, 데이터 주소 레지스터와 같이 하나의 명령어를 처리하기 위해 필요한 레지스터를 여러개 가지고 있으면 됨
  - 만약 레지스터 세트가 2개라면 두 개의 명령어를 처리하기 위한 정보들을 기억할 수 있음

- 하드웨어 스레드: 하나의 코어로도 여러 명령어를 동시에 처리 가능  
  => 메모리 입장에서는 한번에 하나의 명령어를 처리하는 CPU가 여러개 있는 것처럼 보임 = 논리프로세서가 여러개인 것으로 보임
  ![!\[alt text\](image.png)](논리프로세서.png)
  => 논리 프로세서가 4인 것으로 나옴

#### 코어와 스레드의 차이
- 코어 : 명령어를 실행할 수 있는 '하드웨어 부품'
- 스레드 : 명령어를 실행하는 단위

<br>

- 멀티코어 프로세서 : 명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 두 개 이상 있는 CPU
- 멀티스레드 프로세서 : 하나의 코어로 여러개의 명령어를 동시에 실행할 수 있는 CPU

### 5-2. 명령어 병렬 처리 기법
- CPU의 속도를 빠르게 하려면 CPU가 놀지 않고 시간을 알뜰하게 쓰며 작동하게 만드는 것도 중요
- 명령어 병렬 처리 기법 : 명령어 파이프라이닝, 슈퍼스칼라, 비순차적 명령어 처리

#### 명령어 파이프라인
- 하나의 명령어가 처리되는 전체 과정을 비슷한 시간 간격으로 나누어보기
  - 명령어 처리 과정을 클럭 단위로 나눈 경우
    1. 명령어 인출 (Instruction Fetch)
    2. 명령어 해석 (Instruction Decode)
    3. 명령어 실행 (Execute Instruction)
    4. 결과 저장 (Write Back)

- 같은 단계가 겹치지만 않는다면 CPU는 각 단계를 동시에 실행할 수 있음
  - 예시 : 한 명령어를 '인출'하는 동안 다른 명령어를 '실행'할 수 있고, 한 명령어가 '실행'되는 동안 연산 결과를 '저장'할 수 있음
  - 명령어를 겹쳐서 수행 가능
  ![!\[!\\[alt text\\](image.png)\](<CPU 동시 명령어 처리.png>)  ](<명령 파이프라인.png>)

- ***명령어 파이프라인***에 넣고 동시에 처리하는 기법 = ***명령어 파이프라이닝***

- 파이프라인 위험 : 특정 상황에서 파이프라이닝 시 성능 향상을 실패한 경우
  ![!\[alt text\](image.png)](<파이프라인 위험.png>)

##### 데이터 위험
- 명령어 간 '데이터 의존성'에 의해 발생
- 어떤 명령어는 이전 명령어를 끝까지 실행해야만 비로소 실행할 수 있는 경우가 있음
- 의존적인 두 명령어를 무작정 동시에 실행하려고 하면 파이프라인이 제대로 작동하지 않는 것을 '데이터 위험'이라고 함

##### 제어 위험
- 주로 분기 등으로 인한 '프로그램 카운터의 갑작스러운 변화'에 의해 발생
- 기본적으로 프로그램 카운터는 '현재 실행 중인 명령어의 다음 주소'로 갱신
  - 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 갑작스러운 변화가 생기면 명령어 파이프라인에 미리 처리 중이었던 명령어들은 아무 쓸모가 없어짐
- 이를 위해 사용하는 기술 = 분기 예측
  - 분기 예측 : 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술

##### 구조적 위험(자원 위험)
- 명령들을 겹쳐 실행 하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용 하려고 할 때 발생

### 슈퍼스칼라
- CPU의 내부에 여러개의 명령어 파이프라인을 포함한 구조
- 파이프라인을 하나만 두는 것이 공장 생산 라인을 한 개 두는 것과 같다면 슈퍼스칼라는 공장 생산 라인을 여러개 두는 것과 같음
- 슈퍼스칼라 프로세서 or 슈퍼스칼라 CPU = 슈퍼 스칼라 구조로 명령어 처리가 가능한 CPU
  - 매 클럭 주기마다 동시에 여러 명령어를 인출 할 수도 실행 할 수도 있음
  - 멀티스레드 프로세스 여러 명령어를 인출하고 해석하고 실행할 수 있기 때문에 슈퍼스칼라 구조를 사용할 수 있음
- 이론적으로 슈퍼 스칼라 프로세스의 경우 파이프라인 개수를 비례하여 프로그램 처리 속도가 빨라짐
  - 파이프라인 위험 등의 예상치 못한 문제가 있어 실제로는 반드시 파이프라인 개수의 비례하여 빨라지는

### 비순차적 명령어 처리 (OoOE: Out-of-Order Exection)
- 명령어들을 순차적으로 실행하지 않는 기법 (명령어의 합법적 새치기)
- 명령어를 순차적으로만 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법

## 5-3. CISC와 RISC
- 명령어 파이프라이닝과 슈퍼스칼라 기법을 실제로 CPU에 적용하려면 명령어가 파이프라이닝에 최적화되어 있어야 함
- CPU의 언어인 ISA와 다른 성격의 ISA를 기반으로 설계된 CISC, RISC가 있음

### 명령어 집합
- 명령어 집합(instruction set) or 명령어 집합 구조(Instruction Set Architecture) : CPU가 이해할 수 있는 명령어들의 모음
- CPU마다 ISA가 다를 수 있음
-  같은 소스 코드로 만들어진 같은 프로그램이라 할지라도 ISA가 다르면 CPU가 이해할 수 있는 명령어, 어셈블리어도 달라짐
- ISA가 같은 CPU끼리는 서로의 명령어를 이해할 수 있지만, ISA가 다르면 서로의 명령어를 이해하지 못함. 이런 점에서 볼때 ISA는 일종의 CPU의 언어인셈
- ISA에 따라 제어장치가 명령어를 해석하는 방식, 사용되는 레지스터의 종류와 개수, 메모리 관리 방법 등 많은 것이 달라짐 => CPU 하드웨어 설계에도 영향을 미침
- ISA는 CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할 지에 대한 약속
  ![!\[alt text\](image.png)](ISA.png)

### CISC
- CISC(Complex Instruction Set Computer) : 복잡한 명령어 집합을 활용하는 컴퓨터
  - 명령어의 형태와 크기가 다양한 가변 길이 명령어 사용   
    => 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있음
  - 프로그램을 실행하는 명령어 수가 적다는 말은 '컴파일된 프로그램의 크기가 작다'는 것을 의미함   
    => 같은 소스 코드를 컴파일해도 CPU마다 생성되는 실행 파일의 크기가 다를 수 있음

- CISC의 장점
  - 적은 수의 명령어만으로도 프로그램을 동작시킬 수 있다는 것은 메모리 공간을 절약할 수 있다는 장점이 있음

- CISC의 단점
  - 활용하는 명령어가 워낙 복잡하고 다양한 기능을 제공하기 때문에 명령어의 크기와 실행되기까지의 시간이 일정하지 않음
  - 복잡한 명령어 때문에 명령어 하나를 실행하는데에 여러 클럭 주기를 필요로 함 => 명령어 파이프라인을 구현하는데 어려움이 있음
  - 대다수의 복잡한 명령어는 그 사용 빈도가 낮음

- CISC 정리
  - 복잡하고 다양한 기능을 제공하기에 적은 수의 명령으로 프로그램을 동작시키고 메모리를 절약할 수 있지만, 명령어의 규격화가 어려워 파이프라이닝이 어려움
  - 대다수의 복잡한 명령어는 사용빈도가 낮음

### RISC
- RISC(Reduced Instruction Set Computer) : CISC의 한계를 극복하고자 나온 ISA
  
- 원칙
  1. 빠른 처리를 위해 명령어 파이프라인을 십분 활용해야함, 원활한 파이프라이닝을 위해 '명령어 길이와 수행 시간이 짧고 규격화'되어 있어야 함
  2. 어차피 자주 쓰이는 명령어만 줄곧 사용됨, 복잡한 기능을 지원하는 명령어를 추가하기보다 '자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것'이 중요함
   
- 특징
  1. CISC에 비해 명령어의 종류가 적음
  2. CISC와는 달리 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향함
  3. 명령어 파이프라이닝에 최적화됨
  4. 메모리에 접근하는 명령어를 load, store 두 개로 제한할만큼 메모리 접근을 단순화하고 최소화함
  5. 메모리 접근을 최소화, 단순화하는 대신 레지스터를 적극적으로 활용
  6. 레지스터를 이용하는 연산이 많고 범용 레지스터 개수도 많음
  7. 사용 가능한 명령어 개수가 적기 때문에 많은 명령으로 프로그램을 작동시킴

### 정리
- CPU의 언어인 ISA와 각기 다른 성격의 ISA를 기반으로 만들어진 CPU 설계 방식인 CISC, RISC 차이 정리
![!\[alt text\](image.png)](<CISC, RISC 차이.png>)


## Q&A
### Q1. 멀티코어 프로세서와 멀티스레드 프로세서를 설명하시오.
A1. 멀티코어 프로세서는 명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 두 개 이상 있는 CPU를 의미합니다. 멀티 스레드 프로세서란 하나의 코어로 여러개의 명령어를 동시에 실행할 수 있는 CPU를 의미합니다.

### Q2. 명령어 파이프라인과 파이프라인 위험에 대해 설명하고 파이프라인의 위험을 피하기 위한 방식이 무엇인지 설명하시오.
A2. 명령어 파이프라인이란 명령어가 처리되는 단계가 겹쳐지지 않는다면 동시에 여러 단계를 실행할 수 있는 CPU의 특성을 통해 각 단계를 명령어 파이프라인에 넣고 동시에 처리하는 기법입니다.

파이프라인은 총 3개의 위험이 존재할 수 있습니다. 먼저 데이터 위험은 의존적인 명령어를 무작정 동시에 실행하려고 하면 작동하지 않는 경우를 말합니다. 다음으로 제어 위험은 분기로 인해 프로그램 카운터의 갑작스러운 변화가 생겨 명령어 파이프라인에 미리 처리 중이었던 명령어들이 쓸모 없어지는 경우를 말합니다. 마지막으로 구조적 위험은 명령들을 겹쳐 실행하는 과정에 동시에 ALU, 레지스터와 같은 CPU 부품을 사용하려고 할 때 발생합니다.

파이프라인의 위험을 피하기 위한 방식으로 비순차적 명령어 처리가 있습니다. 이는 명령어를 순차적으로 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법입니다.

### Q3. ISA와 CISC, RISC에 대해 설명하시오.
A3. ISA는 CPU의 언어라고 볼 수 있으면 CISC와 RISC는 ISA의 각기 다른 설계 방식입니다.

CISC는 복잡하고 다양한 명령어를 사용하며 가변 길이 명령어를 사용합니다. 다양한 주소 지정 방식을 사용하고 프로그램을 이루는 명령어의 수가 적습니다. 여러 클럭에 걸쳐 명령어를 수행하기 때문에 파이프라이닝이 어렵다는 단점이 있습니다.

RISC는 단순하고 적은 명령어를 사용하며 고정 길이 명령어로 적은 주소 지정 방식을 사용합니다. 프로그램을 이루는 명령어의 수가 많지만 1클럭 내외로 명령어를 수행하기 때문에 파이프라이닝을 하기 쉽습니다.