<aside>
<img src="/icons/drafts_purple.svg" alt="/icons/drafts_purple.svg" width="40px" /> **NOTES**

# 명령어 사이클과 인터럽트

- 명령어 사이클 : 하나의 명령어를 처리하는 정형화된 흐름
- 인터럽트 : 이 흐름이 끊어지는 상황

## 명령어 사이클(instruction cycle)

프로그램은 수많은 명령어로 이루어져 있고, CPU는 이 명령어들을 하나씩 실행 →  프로그램 속 각각의 명령어들은 일정한 주기 반복되며 실행

⇒  이 주기; **명령어 사이클**

(즉, 하나의 명령어가 처리되는 주기)

1. `인출 사이클` : 메모리에 있는 명령어를 CPU로 가지고 오는 단계
2. `실행 사이클` : CPU로 가져온 명령어 실행
3. `간접 사이클` : 명령어 인출해서 CPU로 가져와도 바로 실행X인 경우
    
    ex) 간접 주소 지정 방식 - 오퍼랜드 필드에 유효 주소의 주소 명시, 이 명령어 인출해서 CPU로 가져와도 바로 실행 사이클 돌입X → 명령어 실행 위해서는 메모리 접근 한 번 더 해야 하기 때문
    

## 인터럽트(interrupt)

CPU의 정상적 작업을 방해하는 신호

### 동기 인터럽트(synchronous interrupts)

CPU에 의해 발생하는 인터럽트 - CPU가 명령어들 수행하다가 예상치 못한 상황에 마주쳤을 때, 발생 ⇒ 예외(exception) 라고 부름

### 비동기 인터럽트(asynchronous interrupts)

주로 입출력장치에 의해 발생하는 인터럽트

- IO 장치가 어떠한 입력 받아들이면 이를 처리하고자 CPU에 입력 알림(인터럽트) 보냄

⇒ `하드웨어 인터럽트`

### 하드웨어 인터럽트

- 알림과 같은 인터럽트
- CPU는 입출력 작업 도중에도 효율적으로 명령어 처리하기 위해 이런 알림과 같은 하드웨어 인터럽트 사용

**하드웨어 인터럽트 처리 순서**

1. 입출력 장치는 CPU에 `인터럽트 요청 신호` 보냄
2. CPU는 실행 사이클이 끝나고 명령어 인출하기 전 항상 인터럽트 여부 확인
3. CPU는 인터럽트 요청 확인하고 `인터럽트 플래그` 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인
4. 인터럽트 받아들일 수 있다면 CPU는 지금까지 작업 백업
5. CPU는 `인터럽트 벡터` 참조하여 `인터럽트 서비스 루틴` 실행
6. 인터럽트 서비스 루틴 실행 끝나면 4에서 백업해 둔 작업 복구하여 실행 재개

- `인터럽트 요청 신호` : CPU의 정상적 실행 흐름 끊는 것이기 때문에, 다른 누군가가 인터럽트 하기 전에 끼어들어도 되는지 CPU에 물어봐야 함.
- `인터럽트 플래그` : CPU가 인터럽트 요청 수용하기 위해서는 플래그 레지스터의 인터럽트 플래그가 활성화 되어 잇어야 함.
- 하드웨어 인터럽트의 종류
    - 막을 수 있는 인터럽트
    - 막을 수 없는 인터럽트
- 인터럽트 서비스 루틴(ISR; Interrupt Service Routine) = 인터럽트 핸들러(Interrupt Handler)
    - 인터럽트를 처리하기 위한 동작들로 이루어진 프로그램
    - 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램
    - 명령어+데이터로 이뤄져 있음 → 프로그램 카운터 비롯한 레지스터들 사용하며 실행됨
- 인터럽트 벡터(Interrupt Vector): 인터럽트 서비스 루틴을 식별하기 위한 정보
    - CPU는 HW 인터럽트 요청 보낸 대상으로부터 `데이터 버스` 를 통해 인터럽트 벡터 전달받음

- CPU가 인터럽트 서비스 루틴 실행하려면 인터럽트 서비스 루틴의 시작 주소 알아야 함
→ `인터럽트 벡터` 통해 알 수 있음

- 인터럽트 요청 받기 전 CPU가 수행하고 있던 내역은 ISR 끝나면 되돌아와서 마저 해야 하기 때문에 지금까지 작업 내역은 어딘가 `백업`
    - CPU는 ISR 실행 전에 프로그램 카운터 값 등 현재 프로그램 재개하기 위해 필요한 모든 내용 스택에 백업
    - 그리고 나서 서비스 루틴 시작 주소가 위치한 곳으로 PC 값 갱신하고 ISR 실행

---

### 예외의 종류

- 예외 발생 시, CPU는 하던 일 중단하고 해당 예외 처리, 예외 처리 후 다시 본래 작업으로 되돌아가 실행 재개
- `폴트(fault)` : 예외 처리한 직후 예외가 발생한 명령어로부터 실행 재개하는 예외
- `트랩(trap)` : 예외 처리한 직후 예외가 발생한 명령어의 다음 명령어로부터 실행 재개하는 예외 → 주로 디버깅 때 사용
- `중단(abort)` : CPU가 실행 중인 프로그램 강제로 중단시킬 수밖에 없는 심각한 오류 발견 시, 발생하는 예외
- `소프트웨어 인터럽트` : 시스템 홍출 발생했을 때 나타남
</aside>


---
<aside>
<img src="/icons/question-mark_purple.svg" alt="/icons/question-mark_purple.svg" width="40px" /> **QUESTIONS**

1. **CPU가 인터럽트를 처리한다는 의미는?**

인터럽트가 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아 온다

1. **명령어 사이클의 3가지 종류와 각 사이클의 의미를 설명하시오.**

인출 사이클이란 메모리에 있는 명령어를 CPU로 가지고 오는 단계이고, 실행 사이클이란 CPU로 가져온 명령어 실행하는 것이며, 간접 사이클은 명령어 인출해서 CPU로 가져와도 바로 실행할 수 없는 경우입니다.

1. **하드웨어의 인터럽트 처리 순서에 대해 설명하시오.**

먼저, 입출력 장치가 CPU에 인터럽트 요청 신호를 보냅니다.

그 후, CPU는 실행 사이클이 끝나고 명령어를 인출하기 전, 인터럽트 여부를 항상 확인하는데, CPU가 인터럽트 요청을 확인하면 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 확인합니다.

확인 후, 인터럽트를 받아들일 수 있다면 CPU는 지금까지 작업을 백업하고, 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행합니다.

인터럽트 서비스 루틴 실행이 끝나면 이전에 백업해 둔 작업을 복구해 실행을 재개합니다.

</aside>