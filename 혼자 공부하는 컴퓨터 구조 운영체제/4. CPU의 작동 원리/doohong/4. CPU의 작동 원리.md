# 혼자 공부하는 컴퓨터 구조 운영체제 

- [혼자 공부하는 컴퓨터 구조 운영체제](#혼자-공부하는-컴퓨터-구조-운영체제)
- [4. ALU와 제어장치](#4-alu와-제어장치)
  - [ALU와 제어장치](#alu와-제어장치)
    - [1장 상기하기](#1장-상기하기)
    - [ALU](#alu)
      - [ALU가 받아들이는 정보](#alu가-받아들이는-정보)
      - [ALU가 내보내는 정보](#alu가-내보내는-정보)
    - [제어장치](#제어장치)
  - [Q\&A](#qa)
    - [Q1. 저급 언어와 고급 언어를 설명하고 이와 연결지어 소스코드를 변환하는 방식을 설명해주세요.](#q1-저급-언어와-고급-언어를-설명하고-이와-연결지어-소스코드를-변환하는-방식을-설명해주세요)
    - [Q2. 명령어의 구조는 어떻게 이루어져있나요?](#q2-명령어의-구조는-어떻게-이루어져있나요)
    - [Q3. 5가지 주소 지정 방식에 대해 간단히 설명하시오.](#q3-5가지-주소-지정-방식에-대해-간단히-설명하시오)


# 4. ALU와 제어장치
## ALU와 제어장치
### 1장 상기하기
- CPU : 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 장치
- CPU 내부
  - ALU : 내부 계산을 담당
  - 제어장치 : 명령어를 읽어 들이고 해석
  - 레지스터 : 작은 임시 저장 장치
![Alt text](<CPU 내부.png>)

### ALU
- ALU의 정보를 받아들이고 내보내는 과정
![!\[Alt text\](image.png)](<ALU 구조.png>)
  - ALU = 계산하는 부품

#### ALU가 받아들이는 정보
- 계산하기 위해서 피연산자와 수행할 연산이 필요
- ALU가 연산과 피연산자를 받아들이는 방법
  - **레지스터**를 통해 **피연산자**를 받아들임
  - **제어장치**로부터 수행할 **연산**을 알려주는 **제어 신호**를 받아들임
  > 레지스터와 제어장치로부터 받아들인 피연산자와 제어 신호로 산술 연산, 논리 연산 등 다양한 연산을 수행

#### ALU가 내보내는 정보
- 연산을 수행한 결과(특정 숫자, 문자, 메모리 주소 등)는 일시적으로 레지스터에 저장 후 메모리 저장
  - 메모리가 CPU에 접근하는 속도 > CPU가 레지스터에 접근하는 속도
    - 매번 결과를 메모리에 저장하게 된다면 접근 속도가 훨씬 더 오래 걸리기 때문에 프로그램 실행 속도가 늦어짐
- 계산과 함께 **플래그**를 내보냄
  - 결과값뿐 아니라 연산 결과에 대한 추가적인 정보를 보내야할 때 사용
  - 플래그 레지스터에 저장됨
  - 예시 
    - 연산 결과가 음수 일 때 '음수'라는 추가 정보를 보내야 함
    - 연산 결과가 레지스터보다 클 때 '결과 값이 너무 크다'라는 추가 정보를 내보내야 함 (overflow)

|플래그 종류|의미|사용 예시|
|:--------:|:---:|:-----:|
|부호 플래그|연산한 결과의 부호를 나타냄|- 1일 경우 계산 결과는 음수 <br> - 0일 경우 계산 결과는 양수를 의미|
|제로 플래그|연산 결과가 0인지 여부를 나타냄|- 1일 경우 연산 결과는 0 <br> - 0일 경우 연산결과는 0이 아님|
|캐리 플래그|연산 결과 올림수나 빌림수가 발생했는지를 나타냄|- 1일 경우 올림수나 빌림수 발생 <br> - 0일 경우 발생 안함|
|오버플로우 플래그|오버플로우가 발생했는지를 나태냄|- 1일 경우 오버플로우 발생 <br> - 0일 경우 발생 안함|
|인터럽트 플래그|인터럽트가 가능한지를 나타냄|- 1일 경우 인터럽트 가능 발생 <br> - 0일 경우 인터럽트 불가능|
|슈퍼바이저 플래그|커널 모드로 실행 중인지, 사용자 모드로 실행 중인지를 나태냄|- 1일 경우 커널 모드로 실행 중 <br> - 0일 경우 사용자 모드로 실행 중|

### 제어장치
- 제어장치 : 제어 신호를 내보내고 명령어를 해석하는 부품
- 제어 신호 : 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호



---
[목차로 돌아가기](#)

---
## Q&A
### Q1. 저급 언어와 고급 언어를 설명하고 이와 연결지어 소스코드를 변환하는 방식을 설명해주세요.
A1. 저급 언어는 컴퓨터가 이해할 수 있는 명령어로 이루어진 기계어와 어셈블리가 있습니다. 이에 반해 고급 언어란 사람이 이해할 수 있는 방식인 프로그래밍 언어로 만들어진 소스 코드입니다. 소스 코드를 변환하는 방식은 전체를 컴파일하여 목적 코드로 넘겨주는 컴파일 방식과 한줄씩 변환하는 인터프리터 방식이 있습니다.

### Q2. 명령어의 구조는 어떻게 이루어져있나요?
A2. 명령어의 구조에는 연산코드인 연산자와 오퍼랜드인 피연산자로 이루어져있습니다. 연산코드는 특정 동작을 작동시키는 명령어이며 오퍼랜드는 연산에 사용할 데이터의 주소나 데이터를 의미합니다.

### Q3. 5가지 주소 지정 방식에 대해 간단히 설명하시오.
A3. 즉시 주소 지정 방식은 연산에 사용할 데이터를 직접 명시하는 방식입니다. 직접 주소 지정 방식는 유효 주소를 직접 명시하는 방식입니다. 간접 주소 지정 방식은 유효 주소의 주소를 명시하는 방법입니다. 레지스터 주소 지정 방식은 레지스터 이름을 직접 명시하는 것입니다. 레지스터 간접 주소 지정 방식은 유효 주소를 저장한 레지스터를 명시하는 방식입니다.

---
[목차로 돌아가기](#)

---